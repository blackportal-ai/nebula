//! Contains the entry points for the grpc endpoints
//!
//! An endpoint has to implement an autogenerated trait of grpc.

use crate::server::metadata_fetchers::{fetch_list_packages, fetch_packages};
use crate::storage::data_source::DataSource;

use super::nebula_package_query_server::NebulaPackageQuery;
use super::{ListPackagesRequest, PackageInfo, PackageList, PackageRequest, SearchPackagesRequest};

use tonic::{Request, Response, Status};

#[derive(Debug)]
pub struct NebulaPackageQueryMockImpl<T>
where
    T: DataSource + Send + Sync,
{
    inner_ds: T,
}

impl<T> NebulaPackageQueryMockImpl<T>
where
    T: DataSource + Send + Sync,
{
    pub fn new(ds: T) -> Self {
        Self { inner_ds: ds }
    }
}

#[tonic::async_trait]
impl<T> NebulaPackageQuery for NebulaPackageQueryMockImpl<T>
where
    T: DataSource + Send + Sync + 'static,
{
    async fn get_package_info(
        &self,
        request: Request<PackageRequest>,
    ) -> Result<Response<PackageInfo>, Status> {
        println!("Got a request: {:?}", request);

        match fetch_packages(
            &self.inner_ds,
            request.get_ref().search_query.as_str(),
            request.get_ref().package_type,
        ) {
            Ok(body) => Ok(Response::new(body)),
            Err(_) => Err(Status::internal("Error handling not implemented")),
        }
    }

    async fn list_packages(
        &self,
        request: Request<ListPackagesRequest>,
    ) -> Result<Response<PackageList>, Status> {
        println!("Got a request: {:?}", request);

        // todo: params from request
        let body = fetch_list_packages(&self.inner_ds, 0, 30, 0);

        Ok(Response::new(body))
    }

    async fn search_packages(
        &self,
        request: Request<SearchPackagesRequest>,
    ) -> Result<Response<PackageList>, Status> {
        println!("Got a request: {:?}", request);

        Err(Status::internal("not implemented"))
    }
}
